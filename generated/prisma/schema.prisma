// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// VideoBlade Enums
enum Platform {
  YOUTUBE
  RUMBLE
  TIKTOK
  VIMEO
  LINKEDIN
}

enum PublishStatus {
  PENDING
  SCHEDULED
  PLATFORM_SCHEDULED // Natively scheduled on the platform
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}

enum VideoPrivacy {
  PUBLIC
  UNLISTED
  PRIVATE
  MUTUAL_FOLLOW_FRIENDS
}

enum MediaType {
  VIDEO
  IMAGE
  TEXT
}

// Better Auth schema - clean implementation
model Account {
  id                    String    @id @default(cuid())
  userId                String
  accountId             String
  providerId            String
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([providerId, accountId])
}

model Session {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  expiresAt DateTime
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  activeOrganizationId String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified Boolean?
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  accounts      Account[]
  sessions      Session[]

  members     Member[]
  invitations Invitation[]
}

model Verification {
  id         String   @id @default(cuid())
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([identifier, value])
}

// Organization Models (Phase 7)
model Organization {
  id        String   @id @default(cuid())
  name      String
  slug      String?  @unique
  logo      String?
  createdAt DateTime @default(now())
  metadata  String?

  members     Member[]
  invitations Invitation[]

  // VideoBlade Relations
  posts               Post[]
  platformConnections PlatformConnection[]
}

model Member {
  id             String       @id @default(cuid())
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  userId         String
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  role           String
  createdAt      DateTime     @default(now())

  @@unique([organizationId, userId])
}

model Invitation {
  id             String       @id @default(cuid())
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  email          String
  role           String?
  status         String
  expiresAt      DateTime
  inviterId      String
  user           User         @relation(fields: [inviterId], references: [id], onDelete: Cascade)
  createdAt      DateTime     @default(now())
}

// VideoBlade Models - Renamed Video to Post for Multi-Format Support
model Post {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Media Type
  type MediaType @default(VIDEO)

  // Content (for Text posts)
  content String? @db.Text

  // S3 Storage (Optional for Text posts)
  s3Key    String?
  s3Bucket String?
  fileName String?
  fileSize BigInt?
  mimeType String?
  duration Int?

  // Metadata
  title        String?
  isIdea       Boolean      @default(false)
  description  String?
  tags         String?
  thumbnailUrl String?
  privacy      VideoPrivacy @default(UNLISTED)

  // Ownership
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  publishJobs PublishJob[]
  comments    Comment[]

  @@index([organizationId])
  @@index([createdAt])
  @@index([type])
}

model PlatformConnection {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Platform info
  platform         Platform
  platformUserId   String
  platformUsername String?

  // OAuth tokens
  accessToken  String
  refreshToken String?
  tokenExpiry  DateTime?

  // Platform-specific data (JSON)
  metadata Json?

  // Status
  isActive Boolean @default(true)

  // Ownership
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  publishJobs     PublishJob[]
  postingSchedule PostingSchedule?
  comments        Comment[]

  // One connection per platform per organization
  @@unique([organizationId, platform])
  @@index([organizationId])
  @@index([platform])
}

model PublishJob {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Job details
  platform Platform
  status   PublishStatus @default(PENDING)

  // Platform-specific metadata (overrides from Post)
  title       String?
  description String?
  tags        String?
  privacy     VideoPrivacy?

  // Scheduling
  scheduledFor DateTime?
  startedAt    DateTime?
  completedAt  DateTime?

  // Result
  platformVideoId  String?
  platformVideoUrl String?
  errorMessage     String?
  retryCount       Int     @default(0)

  // Update logic (for editing already-published posts)
  isUpdate            Boolean @default(false)
  updateTargetVideoId String?

  // Relationships
  metricSnapshots MetricSnapshot[]

  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId String

  platformConnection   PlatformConnection @relation(fields: [platformConnectionId], references: [id], onDelete: Cascade)
  platformConnectionId String

  // Removed: createdBy (User) - ownership is via Post -> Organization

  @@index([postId])
  @@index([platformConnectionId])
  @@index([status])
  @@index([scheduledFor])
}

model PostingSchedule {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Configuration
  timezone String // e.g., "America/Chicago"

  // Slots: Array of { day: number (0-6), times: string[] ("HH:MM") }
  slots Json

  // Relationship
  platformConnection   PlatformConnection @relation(fields: [platformConnectionId], references: [id], onDelete: Cascade)
  platformConnectionId String             @unique

  @@index([platformConnectionId])
}

model MetricSnapshot {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  // The specific publication this snapshot tracks
  publishJob   PublishJob @relation(fields: [publishJobId], references: [id], onDelete: Cascade)
  publishJobId String

  // Metrics (Snapshot at this point in time)
  views    Int @default(0)
  likes    Int @default(0)
  comments Int @default(0)
  shares   Int @default(0)

  @@index([publishJobId])
  @@index([createdAt])
}

// Unified Inbox Models
model Comment {
  id          String   @id @default(cuid())
  platform    Platform
  externalId  String // ID on the platform
  content     String   @db.Text
  publishedAt DateTime

  // Internal Status
  isResolved Boolean @default(false)
  isHidden   Boolean @default(false)

  // Relationships
  platformConnectionId String
  platformConnection   PlatformConnection @relation(fields: [platformConnectionId], references: [id], onDelete: Cascade)

  authorId String
  author   CommentAuthor @relation(fields: [authorId], references: [id])

  postId String? // Our internal Post ID if matched
  post   Post?   @relation(fields: [postId], references: [id])

  externalPostId String? // ID of the post on the platform (if we don't have it locally)

  // Threading
  parentId String?
  parent   Comment?  @relation("CommentThread", fields: [parentId], references: [id])
  replies  Comment[] @relation("CommentThread")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([platform, externalId])
  @@index([platformConnectionId])
  @@index([isResolved])
  @@index([postId])
}

model CommentAuthor {
  id         String   @id @default(cuid())
  platform   Platform
  externalId String
  name       String
  avatarUrl  String?
  profileUrl String?

  comments Comment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([platform, externalId])
}
